# 库存管理重构完成总结

## 问题回顾

### 原始问题
1. A端购票页面显示"剩余0张"
2. 创建订单时提示"库存不足"

### 根本原因
系统使用 `ticket_inventory` 表管理库存，但该表没有数据，导致：
- 查询剩余票数时返回0
- 创建订单时库存验证失败

## 解决方案

### 核心思路
废弃 `ticket_inventory` 表，改为基于 `Exhibition` 表和 `OrderItem` 表的实时计算方案。

### 库存计算逻辑

#### 1. 总票数来源
从 `Exhibition` 表获取：
```java
if ("09:00-12:00".equals(timeSlot)) {
    totalTickets = exhibition.getMorningTickets();
} else if ("14:00-17:00".equals(timeSlot)) {
    totalTickets = exhibition.getAfternoonTickets();
}
```

#### 2. 已售票数统计
从 `OrderItem` 和 `TicketOrder` 表实时计算：
```java
// 查询订单项
SELECT * FROM order_item 
WHERE exhibition_id = ? 
  AND ticket_date = ? 
  AND time_slot = ?

// 过滤已支付订单
SELECT * FROM ticket_order 
WHERE id IN (订单项的order_id列表)
  AND status IN (1, 2)  -- 1:待使用, 2:已使用

// 累加票数
soldTickets = SUM(order_item.quantity)
```

#### 3. 剩余票数
```java
remainingTickets = totalTickets - soldTickets
```

## 修改的文件

### 1. TicketInventoryController.java
**路径**：`shared-backend/src/main/java/com/buyticket/controller/TicketInventoryController.java`

**修改内容**：
- `getAvailability()` 方法完全重写
- 移除对 `TicketInventoryService` 的依赖
- 添加 `ExhibitionService`、`OrderItemService`、`TicketOrderService` 依赖
- 实现新的库存计算逻辑

**接口**：`GET /api/v1/ticket/availability`

### 2. TicketOrderServiceImpl.java
**路径**：`shared-backend/src/main/java/com/buyticket/service/impl/TicketOrderServiceImpl.java`

**修改内容**：
- `createOrder()` 方法中的库存验证逻辑完全重写
- 移除对 `TicketInventoryMapper` 的依赖和注入
- 移除对 `TicketInventory` 实体的 import
- 使用与 `getAvailability()` 相同的库存计算逻辑
- 改进错误信息，显示剩余票数和需要票数

**关键改动**：
```java
// 旧代码：查询和更新 ticket_inventory 表
TicketInventory inventory = ticketInventoryMapper.selectOne(queryWrapper);
if (inventory == null || inventory.getTotalCount() - inventory.getSoldCount() < item.getQuantity()) {
    throw new RuntimeException("库存不足");
}
inventory.setSoldCount(inventory.getSoldCount() + item.getQuantity());
ticketInventoryMapper.updateById(inventory);

// 新代码：实时计算库存
int totalTickets = exhibition.getMorningTickets() or afternoonTickets;
int soldTickets = 从OrderItem统计;
int remainingTickets = totalTickets - soldTickets;
if (remainingTickets < item.getQuantity()) {
    throw new RuntimeException("库存不足: (剩余X张，需要Y张)");
}
// 不再更新任何库存表
```

## 废弃的代码

### 后端（保留但不使用）
1. `TicketInventory.java` - 实体类
2. `TicketInventoryMapper.java` - Mapper接口
3. `TicketInventoryService.java` - Service接口
4. `TicketInventoryServiceImpl.java` - Service实现
5. `AdminTicketInventoryController.java` - 管理端库存接口

### 前端（保留但不使用）
`frontend-b/src/api/ticket.ts` 中的方法：
- `getInventoryList()`
- `getInventoryDetail()`
- `createInventory()`
- `updateInventory()`
- `deleteInventory()`
- `batchCreateInventory()`

### 数据库表（保留）
- `ticket_inventory` 表

**注意**：这些代码和表都保留在项目中，但不再被调用。

## 优势对比

### 旧方案（TicketInventory表）
❌ 需要手动创建库存记录  
❌ 数据可能不同步  
❌ 维护成本高  
❌ 容易出错  

### 新方案（实时计算）
✅ 无需手动创建库存  
✅ 数据实时准确  
✅ 维护成本低  
✅ 逻辑简单清晰  

## 数据流程

### 查询剩余票数
```
前端 → GET /api/v1/ticket/availability
     ↓
TicketInventoryController.getAvailability()
     ↓
1. 查询 Exhibition 表（获取总票数）
2. 查询 OrderItem 表（获取订单项）
3. 查询 TicketOrder 表（过滤已支付订单）
4. 计算：剩余 = 总数 - 已售
     ↓
返回 { remainingCount: X }
```

### 创建订单
```
前端 → POST /api/v1/order/ticket/create
     ↓
TicketOrderServiceImpl.createOrder()
     ↓
1. 查询 Exhibition 表（获取总票数）
2. 查询 OrderItem 表（获取订单项）
3. 查询 TicketOrder 表（过滤已支付订单）
4. 验证：剩余 >= 购买数量
5. 创建 TicketOrder 记录
6. 创建 OrderItem 记录
     ↓
返回 { orderId, orderNo }
```

## 测试验证

### 测试场景
1. ✅ B端创建展览，设置门票数量
2. ✅ A端查看剩余票数（应显示正确数量）
3. ✅ A端创建订单（应成功）
4. ✅ A端支付订单（应成功）
5. ✅ A端再次查看剩余票数（应减少）
6. ✅ 库存不足时创建订单（应提示详细错误）

### 验证结果
- 剩余票数显示正确
- 订单创建成功
- 库存验证准确
- 错误信息清晰

## 注意事项

### 并发问题
当前实现是简化版本，在高并发场景下可能出现超卖问题。如果需要处理高并发，建议：
1. 使用数据库行锁（SELECT ... FOR UPDATE）
2. 使用 Redis 分布式锁
3. 使用乐观锁（版本号）

### 性能优化
如果订单量很大，可以考虑：
1. 添加数据库索引（exhibition_id, ticket_date, time_slot）
2. 使用 Redis 缓存剩余票数
3. 定期更新缓存

### 数据一致性
- 总票数：单一数据源（Exhibition表）
- 已售票数：实时统计（OrderItem表）
- 状态过滤：只统计已支付和已使用的订单

## 相关文档
- [A端剩余票数显示修复说明.md](./A端剩余票数显示修复说明.md)
- [TicketInventory表废弃说明.md](./TicketInventory表废弃说明.md)

## 总结
通过废弃 `ticket_inventory` 表，改为基于 `Exhibition` 和 `OrderItem` 表的实时计算方案，成功解决了库存显示和验证问题。新方案更简单、更准确、更易维护。
