# 展览门票库存管理方案

## 问题分析

### 当前问题
1. 展览有多天（开始日期到结束日期）
2. 每天有多个时间段（上午、下午、晚上等）
3. 每个时间段有独立的门票数量
4. 用户购买后需要实时扣减对应时间段的库存
5. 需要防止超卖

### 业务场景示例
```
展览：梵高画展
日期：2026-02-01 到 2026-02-10（10天）
时间段：
  - 上午场：09:00-12:00（每天100张）
  - 下午场：14:00-17:00（每天150张）
  - 晚上场：19:00-21:00（每天80张）

用户购买：2026-02-05 下午场 2张
结果：2026-02-05下午场剩余 148张
```

## 解决方案

### 方案一：独立库存表（推荐）

#### 表结构设计

```sql
-- 展览时间段库存表
CREATE TABLE exhibition_time_slot_inventory (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    exhibition_id BIGINT NOT NULL COMMENT '展览ID',
    ticket_date DATE NOT NULL COMMENT '门票日期',
    time_slot VARCHAR(50) NOT NULL COMMENT '时间段，如：09:00-12:00',
    total_tickets INT NOT NULL DEFAULT 0 COMMENT '总票数',
    sold_tickets INT NOT NULL DEFAULT 0 COMMENT '已售票数',
    available_tickets INT NOT NULL DEFAULT 0 COMMENT '可售票数',
    version INT NOT NULL DEFAULT 0 COMMENT '乐观锁版本号',
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY uk_exhibition_date_slot (exhibition_id, ticket_date, time_slot),
    INDEX idx_exhibition_id (exhibition_id),
    INDEX idx_ticket_date (ticket_date)
) COMMENT='展览时间段库存表';
```

#### 优点
- ✅ 精确控制每个时间段的库存
- ✅ 支持乐观锁防止超卖
- ✅ 查询性能好
- ✅ 易于扩展（可以添加价格等字段）

#### 缺点
- ❌ 需要额外的表
- ❌ 创建展览时需要初始化库存数据

---

### 方案二：JSON字段存储（灵活但复杂）

#### 表结构
```sql
-- 在exhibition表中添加字段
ALTER TABLE exhibition 
ADD COLUMN time_slot_config JSON COMMENT '时间段配置';

-- JSON结构示例
{
  "timeSlots": [
    {
      "slot": "09:00-12:00",
      "name": "上午场",
      "tickets": 100
    },
    {
      "slot": "14:00-17:00", 
      "name": "下午场",
      "tickets": 150
    }
  ],
  "inventory": {
    "2026-02-01": {
      "09:00-12:00": {"total": 100, "sold": 0},
      "14:00-17:00": {"total": 150, "sold": 0}
    },
    "2026-02-02": {
      "09:00-12:00": {"total": 100, "sold": 5},
      "14:00-17:00": {"total": 150, "sold": 20}
    }
  }
}
```

#### 优点
- ✅ 灵活，不需要额外的表
- ✅ 配置和库存在一起

#### 缺点
- ❌ 查询复杂
- ❌ 并发控制困难
- ❌ 不支持数据库级别的约束
- ❌ 不推荐用于高并发场景

---

## 推荐实现：方案一（独立库存表）

### 1. 创建库存表

```sql
-- 创建库存表
CREATE TABLE exhibition_time_slot_inventory (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    exhibition_id BIGINT NOT NULL COMMENT '展览ID',
    ticket_date DATE NOT NULL COMMENT '门票日期',
    time_slot VARCHAR(50) NOT NULL COMMENT '时间段',
    total_tickets INT NOT NULL DEFAULT 0 COMMENT '总票数',
    sold_tickets INT NOT NULL DEFAULT 0 COMMENT '已售票数',
    available_tickets INT NOT NULL DEFAULT 0 COMMENT '可售票数',
    version INT NOT NULL DEFAULT 0 COMMENT '乐观锁版本号',
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY uk_exhibition_date_slot (exhibition_id, ticket_date, time_slot),
    INDEX idx_exhibition_id (exhibition_id),
    INDEX idx_ticket_date (ticket_date)
) COMMENT='展览时间段库存表';
```

### 2. 初始化库存数据

当创建展览时，自动生成库存记录：

```java
// 创建展览后，初始化库存
public void initializeInventory(Exhibition exhibition) {
    LocalDate startDate = exhibition.getStartDate();
    LocalDate endDate = exhibition.getEndDate();
    
    // 时间段配置（可以从配置文件或数据库读取）
    List<TimeSlotConfig> timeSlots = Arrays.asList(
        new TimeSlotConfig("09:00-12:00", "上午场", 100),
        new TimeSlotConfig("14:00-17:00", "下午场", 150),
        new TimeSlotConfig("19:00-21:00", "晚上场", 80)
    );
    
    // 遍历每一天
    LocalDate currentDate = startDate;
    while (!currentDate.isAfter(endDate)) {
        for (TimeSlotConfig slot : timeSlots) {
            ExhibitionTimeSlotInventory inventory = new ExhibitionTimeSlotInventory();
            inventory.setExhibitionId(exhibition.getId());
            inventory.setTicketDate(currentDate);
            inventory.setTimeSlot(slot.getSlot());
            inventory.setTotalTickets(slot.getTickets());
            inventory.setSoldTickets(0);
            inventory.setAvailableTickets(slot.getTickets());
            inventory.setVersion(0);
            
            inventoryService.save(inventory);
        }
        currentDate = currentDate.plusDays(1);
    }
}
```

### 3. 查询可用库存

```java
/**
 * 查询指定日期和时间段的可用库存
 */
public ExhibitionTimeSlotInventory getAvailableInventory(
    Long exhibitionId, 
    LocalDate ticketDate, 
    String timeSlot
) {
    LambdaQueryWrapper<ExhibitionTimeSlotInventory> query = new LambdaQueryWrapper<>();
    query.eq(ExhibitionTimeSlotInventory::getExhibitionId, exhibitionId)
         .eq(ExhibitionTimeSlotInventory::getTicketDate, ticketDate)
         .eq(ExhibitionTimeSlotInventory::getTimeSlot, timeSlot);
    
    return inventoryMapper.selectOne(query);
}
```

### 4. 扣减库存（使用乐观锁）

```java
/**
 * 扣减库存（乐观锁）
 */
public boolean decreaseInventory(
    Long exhibitionId, 
    LocalDate ticketDate, 
    String timeSlot, 
    int quantity
) {
    // 1. 查询当前库存
    ExhibitionTimeSlotInventory inventory = getAvailableInventory(
        exhibitionId, ticketDate, timeSlot
    );
    
    if (inventory == null) {
        throw new BusinessException("库存记录不存在");
    }
    
    // 2. 检查库存是否足够
    if (inventory.getAvailableTickets() < quantity) {
        throw new BusinessException("库存不足");
    }
    
    // 3. 使用乐观锁更新库存
    int oldVersion = inventory.getVersion();
    int newSoldTickets = inventory.getSoldTickets() + quantity;
    int newAvailableTickets = inventory.getAvailableTickets() - quantity;
    
    // SQL: UPDATE ... SET sold_tickets = ?, available_tickets = ?, 
    //      version = version + 1 WHERE id = ? AND version = ?
    UpdateWrapper<ExhibitionTimeSlotInventory> updateWrapper = new UpdateWrapper<>();
    updateWrapper.eq("id", inventory.getId())
                 .eq("version", oldVersion)
                 .set("sold_tickets", newSoldTickets)
                 .set("available_tickets", newAvailableTickets)
                 .setSql("version = version + 1");
    
    int updated = inventoryMapper.update(null, updateWrapper);
    
    // 4. 如果更新失败（版本号不匹配），说明有并发冲突
    if (updated == 0) {
        throw new BusinessException("库存更新失败，请重试");
    }
    
    return true;
}
```

### 5. 创建订单流程

```java
@Transactional(rollbackFor = Exception.class)
public TicketOrder createOrder(CreateOrderRequest request) {
    // 1. 验证展览是否存在
    Exhibition exhibition = exhibitionService.getById(request.getExhibitionId());
    if (exhibition == null) {
        throw new BusinessException("展览不存在");
    }
    
    // 2. 扣减库存（乐观锁）
    try {
        inventoryService.decreaseInventory(
            request.getExhibitionId(),
            request.getTicketDate(),
            request.getTimeSlot(),
            request.getQuantity()
        );
    } catch (BusinessException e) {
        // 库存不足或并发冲突
        throw e;
    }
    
    // 3. 创建订单
    TicketOrder order = new TicketOrder();
    order.setUserId(getCurrentUserId());
    order.setExhibitionId(request.getExhibitionId());
    order.setTicketDate(request.getTicketDate());
    order.setTimeSlot(request.getTimeSlot());
    order.setQuantity(request.getQuantity());
    order.setTotalAmount(exhibition.getPrice().multiply(new BigDecimal(request.getQuantity())));
    order.setStatus(0); // 待支付
    
    orderService.save(order);
    
    return order;
}
```

### 6. 取消订单（恢复库存）

```java
@Transactional(rollbackFor = Exception.class)
public void cancelOrder(Long orderId) {
    // 1. 查询订单
    TicketOrder order = orderService.getById(orderId);
    if (order == null) {
        throw new BusinessException("订单不存在");
    }
    
    // 2. 只有待支付的订单才能取消
    if (order.getStatus() != 0) {
        throw new BusinessException("订单状态不允许取消");
    }
    
    // 3. 恢复库存
    inventoryService.increaseInventory(
        order.getExhibitionId(),
        order.getTicketDate(),
        order.getTimeSlot(),
        order.getQuantity()
    );
    
    // 4. 更新订单状态
    order.setStatus(3); // 已取消
    orderService.updateById(order);
}
```

---

## 前端展示

### 1. 选择日期和时间段

```vue
<template>
  <div class="ticket-booking">
    <!-- 日期选择 -->
    <el-date-picker
      v-model="selectedDate"
      type="date"
      placeholder="选择日期"
      :disabled-date="disabledDate"
      @change="loadTimeSlots"
    />
    
    <!-- 时间段选择 -->
    <div class="time-slots">
      <div 
        v-for="slot in timeSlots" 
        :key="slot.timeSlot"
        class="time-slot-card"
        :class="{ disabled: slot.availableTickets === 0 }"
        @click="selectTimeSlot(slot)"
      >
        <div class="slot-time">{{ slot.timeSlot }}</div>
        <div class="slot-name">{{ slot.name }}</div>
        <div class="slot-tickets">
          剩余：{{ slot.availableTickets }}张
        </div>
      </div>
    </div>
    
    <!-- 数量选择 -->
    <el-input-number 
      v-model="quantity" 
      :min="1" 
      :max="selectedSlot?.availableTickets || 1"
    />
    
    <!-- 提交按钮 -->
    <el-button type="primary" @click="createOrder">
      立即购买
    </el-button>
  </div>
</template>

<script setup>
const selectedDate = ref(null)
const selectedSlot = ref(null)
const quantity = ref(1)
const timeSlots = ref([])

// 加载时间段库存
const loadTimeSlots = async () => {
  const data = await api.getTimeSlotInventory({
    exhibitionId: props.exhibitionId,
    date: selectedDate.value
  })
  timeSlots.value = data
}

// 创建订单
const createOrder = async () => {
  await api.createOrder({
    exhibitionId: props.exhibitionId,
    ticketDate: selectedDate.value,
    timeSlot: selectedSlot.value.timeSlot,
    quantity: quantity.value
  })
  ElMessage.success('购买成功')
}
</script>
```

---

## 并发控制

### 乐观锁原理

```
用户A查询库存：剩余100张，version=1
用户B查询库存：剩余100张，version=1

用户A购买10张：
  UPDATE ... SET sold=10, available=90, version=2 WHERE id=1 AND version=1
  ✅ 成功（version匹配）

用户B购买20张：
  UPDATE ... SET sold=20, available=80, version=2 WHERE id=1 AND version=1
  ❌ 失败（version已经是2了，不匹配）
  → 提示用户重试
```

### 防止超卖

1. **数据库约束**：available_tickets >= 0
2. **乐观锁**：version字段
3. **事务**：@Transactional
4. **库存检查**：扣减前检查

---

## 性能优化

### 1. 缓存热门展览库存

```java
@Cacheable(value = "inventory", key = "#exhibitionId + ':' + #date + ':' + #slot")
public ExhibitionTimeSlotInventory getInventory(
    Long exhibitionId, 
    LocalDate date, 
    String slot
) {
    // 查询数据库
}

@CacheEvict(value = "inventory", key = "#exhibitionId + ':' + #date + ':' + #slot")
public void decreaseInventory(...) {
    // 扣减库存后清除缓存
}
```

### 2. 批量查询

```java
// 一次查询某个展览某天的所有时间段库存
public List<ExhibitionTimeSlotInventory> getDateInventory(
    Long exhibitionId, 
    LocalDate date
) {
    LambdaQueryWrapper<ExhibitionTimeSlotInventory> query = new LambdaQueryWrapper<>();
    query.eq(ExhibitionTimeSlotInventory::getExhibitionId, exhibitionId)
         .eq(ExhibitionTimeSlotInventory::getTicketDate, date);
    return inventoryMapper.selectList(query);
}
```

---

## 数据一致性

### 订单状态与库存的关系

| 订单状态 | 库存操作 | 说明 |
|---------|---------|------|
| 待支付(0) | 扣减库存 | 创建订单时扣减 |
| 已支付(1) | 无操作 | 库存已扣减 |
| 已使用(2) | 无操作 | 库存已扣减 |
| 已取消(3) | 恢复库存 | 取消订单时恢复 |
| 已作废(4) | 恢复库存 | 作废订单时恢复 |

### 超时未支付处理

```java
@Scheduled(cron = "0 */5 * * * ?") // 每5分钟执行一次
public void cancelExpiredOrders() {
    // 查询30分钟前创建的待支付订单
    LocalDateTime expireTime = LocalDateTime.now().minusMinutes(30);
    
    LambdaQueryWrapper<TicketOrder> query = new LambdaQueryWrapper<>();
    query.eq(TicketOrder::getStatus, 0)
         .lt(TicketOrder::getCreateTime, expireTime);
    
    List<TicketOrder> expiredOrders = orderService.list(query);
    
    for (TicketOrder order : expiredOrders) {
        // 恢复库存
        inventoryService.increaseInventory(
            order.getExhibitionId(),
            order.getTicketDate(),
            order.getTimeSlot(),
            order.getQuantity()
        );
        
        // 取消订单
        order.setStatus(3);
        orderService.updateById(order);
    }
}
```

---

## 总结

### 推荐方案
使用**独立库存表 + 乐观锁**的方案，因为：
1. ✅ 精确控制每个时间段库存
2. ✅ 防止超卖
3. ✅ 性能好
4. ✅ 易于维护

### 实施步骤
1. 创建 `exhibition_time_slot_inventory` 表
2. 创建展览时初始化库存数据
3. 修改创建订单逻辑，先扣减库存
4. 实现取消订单恢复库存
5. 添加定时任务处理超时订单
6. 前端展示实时库存

### 注意事项
- 使用事务保证数据一致性
- 使用乐观锁防止并发问题
- 及时清理过期订单恢复库存
- 考虑缓存提升性能
