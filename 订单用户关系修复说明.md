# 订单用户关系修复说明

## 问题描述
每个用户看到的门票订单都是一样的，没有按照用户ID过滤。

## 根本原因
前端发送token时没有添加 `Bearer ` 前缀，导致JWT拦截器无法正确解析token，`UserContext.getUserId()` 返回null，后端查询时没有正确过滤用户。

## 数据关系

### 正确的关系
- **用户 : 订单 = 1 : N**（一个用户可以有多个订单）
- **订单 : 用户 = 1 : 1**（一个订单只属于一个用户）

### 数据库表结构
```
sys_user (用户表)
├── id (主键)
├── username
└── ...

ticket_order (订单表)
├── id (主键)
├── user_id (外键 → sys_user.id)
├── order_no
├── total_amount
├── status
└── ...

order_item (订单项表)
├── id (主键)
├── order_id (外键 → ticket_order.id)
├── exhibition_id
├── exhibition_name
└── ...
```

## 修复方案

### 1. 修复前端Token格式 ✅

**文件**：`frontend-a/src/utils/request.ts`

**问题**：
```typescript
// 错误：直接发送token
config.headers.Authorization = token
```

**修复**：
```typescript
// 正确：添加Bearer前缀
config.headers.Authorization = `Bearer ${token}`
```

### 2. JWT拦截器验证流程

**文件**：`shared-backend/src/main/java/com/buyticket/interceptor/JwtInterceptor.java`

**流程**：
1. 从请求头获取 `Authorization`
2. 检查是否以 `Bearer ` 开头
3. 去掉前缀，获取纯token
4. 验证token有效性
5. 解析token，获取userId
6. 设置到 `UserContext`

**代码**：
```java
String token = request.getHeader("Authorization");
if (token != null && token.startsWith("Bearer ")) {
    token = token.substring(7); // 去掉 "Bearer "
}
// 验证和解析token
Claims claims = JwtUtils.getClaimsByToken(token);
Long userId = Long.parseLong(claims.getSubject());
UserContext.setUserId(userId);
```

### 3. 后端订单查询

**文件**：`shared-backend/src/main/java/com/buyticket/controller/OrderController.java`

**代码**：
```java
@GetMapping("/ticket/list")
public JsonData listTicketOrders() {
    Long userId = getCurrentUserId(); // 从UserContext获取
    return JsonData.buildSuccess(ticketOrderService.list(
        new LambdaQueryWrapper<TicketOrder>()
            .eq(TicketOrder::getUserId, userId) // 按用户ID过滤
            .orderByDesc(TicketOrder::getCreateTime)
    ));
}
```

## 测试验证

### 1. 检查Token格式
打开浏览器开发者工具 → Network → 选择任意API请求 → Headers：
```
Authorization: Bearer eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9...
```

### 2. 测试不同用户
1. 用户A登录，创建订单
2. 退出登录
3. 用户B登录，创建订单
4. 查看订单列表，应该只看到用户B的订单
5. 切换回用户A，应该只看到用户A的订单

### 3. 数据库验证
运行 `CHECK_ORDER_USER_RELATION.sql`：
```sql
-- 查看订单和用户的关系
SELECT 
    t.id AS order_id,
    t.order_no,
    t.user_id,
    u.username,
    t.total_amount,
    t.status
FROM ticket_order t
LEFT JOIN sys_user u ON t.user_id = u.id
ORDER BY t.create_time DESC;
```

应该看到每个订单都有对应的 `user_id`。

## 其他端的修复

### B端（frontend-b）
B端使用管理员登录，需要同样的修复：
```typescript
// frontend-b/src/utils/request.ts
config.headers.Authorization = `Bearer ${token}`
```

### C端（frontend-c）
C端使用核销功能，需要同样的修复：
```typescript
// frontend-c/src/utils/request.ts
config.headers.Authorization = `Bearer ${token}`
```

## 注意事项

### Token存储
- Token存储在 `localStorage.getItem('token')`
- 登录成功后保存：`localStorage.setItem('token', res.token)`
- 退出登录时清除：`localStorage.removeItem('token')`

### Token格式
- **标准格式**：`Bearer <token>`
- **Bearer** 后面有一个空格
- 这是OAuth 2.0的标准格式

### 安全性
1. Token包含用户ID和角色信息
2. Token有过期时间（7天）
3. Token使用HS512算法加密
4. 不要在URL中传递token
5. 生产环境使用HTTPS

## 常见问题

### Q1: 为什么需要Bearer前缀？
A: 这是OAuth 2.0的标准格式，表示使用Bearer Token认证方式。

### Q2: 如果token格式错误会怎样？
A: JWT拦截器会返回401错误，提示"未登录或token已过期"。

### Q3: 如何调试token问题？
A: 
1. 检查浏览器开发者工具的Network标签
2. 查看请求头的Authorization字段
3. 检查后端日志
4. 使用jwt.io网站解析token内容

### Q4: 为什么之前没有这个问题？
A: 之前使用硬编码的用户ID（`return 1L;`），所以所有用户看到的都是用户1的订单。

## 总结

通过添加 `Bearer ` 前缀，JWT拦截器可以正确解析token，获取用户ID，后端接口就能正确过滤每个用户的订单。这样就实现了：
- ✅ 每个用户只能看到自己的订单
- ✅ 订单和用户是1:1关系
- ✅ 用户和订单是1:N关系
- ✅ 数据隔离和安全性
